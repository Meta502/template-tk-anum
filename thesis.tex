%% Template for ENG 401 reports
%% by Robin Turner
%% Adapted from the IEEE peer review template

\documentclass[journal,12pt,onecolumn,a4paper]{IEEEtran}
\usepackage{cite} % Tidies up citation numbers.
\usepackage{url} % Provides better formatting of URLs.
\usepackage[utf8]{inputenc} % Allows Turkish characters.
\usepackage{booktabs} % Allows the use of \toprule, \midrule and \bottomrule in tables for horizontal lines
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{float}
\usepackage{multicol}
\usepackage{listings}
\usepackage[numbered,framed]{matlab-prettifier}
\usepackage[export]{adjustbox}
\usepackage{titlesec}

\graphicspath{ {./images/} }

\hyphenation{op-tical net-works semi-conduc-tor} % Corrects some bad hyphenation 
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}


\begin{document}
\begin{titlepage}
	% paper title
	% can use linebreaks \\ within to get better formatting as desired
	\title{Interpolasi Numerik: Path Calculator}


	% author names and affiliations

	\author{Adrian Ardizza\\
		Alya Azhar Agharid\\
		Muhammad Athallah\\
		Stefanus Ndaru Wedhatama
	}

	% make the title area
	\maketitle
	\begin{abstract}
		The abstract does not only mention the paper but is the original paper shrunken to approximately 200 words. It states the purpose, reports the information obtained, and gives conclusions, and recommendations. In short, it summarizes the main points of the study adequately and accurately. It provides information from every major section in the body of the report in a dense and compact way. Past tense and active voice is appropriate when describing what was done. If there is any, it includes key statistical detail.

		Depending on the format you use, the abstract may come on the title page or at the beginning of the main report.

	\end{abstract}
	\tableofcontents
	\listoffigures
	\listoftables
\end{titlepage}

\IEEEpeerreviewmaketitle

\section{Pendahuluan}
Interpolasi merupakan teknik yang digunakan untuk membangun suatu fungsi yang melewati sebuah himpunan titik-titik diskret yang diketahui. Fungsi interpolasi memiliki aplikasi yang luas pada Ilmu Komputer karena dapat digunakan untuk menggambarkan berbagai kurva kompleks dengan \emph{computational cost} yang relatif murah apabila dibandingkan dengan metode brute-force (mencari seluruh titik yang memenuhi suatu kurva secara \emph{exhaustive}). Interpolasi beberapa titik diskret dapat dicapai dengan berbagai metode interpolasi seperti interpolasi konstan, interpolasi linear, interpolasi polinomial, dan interpolasi \emph{spline} yang menjadi topik dari paper ini.

Secara matematis, sebuah fungsi interpolasi dapat dinyatakan sebagai suatu fungsi \(P(x)\) dimana \(x\) adalah sebuah titik yang ingin di-interpolasi. Hasil dari fungsi tersebut adalah sebuah value yang merupakan aproksimasi dari nilai fungsi \(f(x)\) yang melewati seluruh titik-titik diskret yang nilainya sudah diketahui.

Pada paper ini, kami ingin mengeksplorasi pemanfaatan sebuah fungsi \emph{cubic spline} - atau lebih tepatnya fungsi \emph{cubic spline} dengan kondisi \emph{natural} - untuk melakukan \emph{smoothing} pada perubahan posisi suatu titik di interval waktu \([0, n]\). Cubic spline dapat didefinisikan sebagai suatu \emph{piecewise polyomial function} yang menginterpolasi sebuah titik
\section{Metode Integrasi Romberg}
\subsection{Pengenalan Algoritma Romberg}
\emph{Romberg Integration} merupakan metode integrasi yang menggunakan prinsip \emph{trapezoidal rule} dan meningkatkan akurasi dengan melakukan ekstrapolasi melalui \emph{Richardson's Extrapolation}.

\emph{Romberg} bekerja dengan menggunakan \emph{Trapezoidal Rule} sebagai basis dari perhitungan dan melakukan iterasi dengan melakukan pembagian interval untuk meningkatkan akurasi. Basis ini diiterasi per-baris pada suatu tabel Romberg yang memiliki ukuran \(R(n,n)\) melalui rumus

\begin{equation*}
	\begin{split}
		R(1,1) & = (b-a)\frac{f(a)+f(b)}{2} \\
		R(j,1) & = \frac{1}{2}R_{j-1,1}+h_j\sum_{i=1}^{2^{j-2}}f(a+(2i-1)h_j)
	\end{split}
\end{equation*}

Jika dilihat, \(R(1,1)\) perlu diinisiasi terlebih dahulu karena untuk iterasi berikutnya, akan menggunakan hasil dari iterasi sebelumnya karena bersifat \emph{evolutionary} dengan arti meningkatkan akurasi dari iterasi sebelumnya dengan membagi interval \(h\) menjadi lebih kecil. Nilai \(h\) ini diperkecil setiap iterasi melalui rumus

\begin{equation*}
	\begin{split}
		h_j & = \frac{b-a}{2^{j-1}}
	\end{split}
\end{equation*}

Dari sini, kita bisa membentuk tabel Romberg \(R\) yang memiliki iterasi \emph{trapezoidal rule} dengan iterasi setiap baris, di mana semakin banyak iterasi (dan baris semakin ke bawah), maka akurasi akan semakin meningkat karena memiliki jarak interval \(h\) yang semakin kecil.

Untuk setiap baris, kita bisa menemukan akurasi yang lebih tinggi dengan mengekstrapolasi menggunakan \emph{Richardson's Extrapolation} yang mengekstrapolasi hasil dari \emph{Trapezoidal Rule} yang diperoleh. Rumus \emph{Richardson's Extrapolation} yang sudah diadaptasi untuk algoritma Romberg ini dapat dilihat sebagai berikut

\begin{equation*}
	\begin{split}
		R_{j,k} & = \frac{4^{k-1}R_{j,k-1}-R_{j-1,k-1}}{4^{k-1}-1}
	\end{split}
\end{equation*}

Dengan demikian, kita bisa mengerti bahwa algoritma Romberg melakukan integrasi dengan membangun tabel Romberg \(R\) dengan ukuran \(R(n,n)\) dan mengisi tabel tersebut sehingga membentuk \emph{lower triangular matrix} di mana setiap baris merupakan iterasi \emph{trapezoidal rule} dan setiap kolom merupakan peningkatan akurasi dari \emph{trapezoidal rule} baris tersebut menggunakan \emph{richardson's extrapolation} dengan meningkatkan \emph{order of accuracy} melalui hasil yang diperoleh pada iterasi-iterasi sebelumnya (yang akan dibahas pada \emph{subsection} toleransi eror di bawah). Dengan demikian, sebuah tabel Romberg yang dihasilkan dapat divisualisasikan sebagai berikut

\begin{center}
	\begin{tabular}{ c | c c c c c }

		j/k        & \(R(j,0)\) & \(R(j,1)\) & \(R(j,2)\) & \(R(j,3)\) & \(\cdots\) \\
		\hline
		0          & \(R(0,0)\) & -          & -          & -          & -          \\
		1          & \(R(1,0)\) & \(R(1,1)\) & -          & -          & -          \\
		2          & \(R(2,0)\) & \(R(2,1)\) & \(R(2,2)\) & -          & -          \\
		3          & \(R(3,0)\) & \(R(3,1)\) & \(R(3,2)\) & \(R(3,3)\) & -          \\
		\(\vdots\) & \(\vdots\) & \(\vdots\) & \(\vdots\) & \(\vdots\) & \(\ddots\) \\
	\end{tabular}
\end{center}

Sesuai dengan prinsip yang dijelaskan di atas, akurasi ditingkatkan dengan ekstrapolasi setiap kolomnya dengan semakin meningkat kolom (semakin ke kanan), maka hasil akan semakin akurat. Dengan demikian, nilai paling akurat untuk setiap iterasi berada pada diagonal matriks tersebut.

Hal ini menciptakan suatu sifat/fenomena konvergensi, di mana nilai hasil integrasi akan semakin konvergen menuju suatu solusi perhitungan untuk setiap diagonal yang ada. Apabila nilai diagonal sudah mencapai hasil, maka akan bersifat konvergen di mana hasil komputasi pada diagonal-diagonal sebelumnya akan mendekati nilai akhir ini, dan dengan setiap iterasi, perbedaannya akan semakin kecil antar diagonal-diagonalnya, dengan diagonal terakhir memiliki nilai paling akurat.

Maka dari itu, untuk memperoleh hasil integrasi, diambil elemen diagonal pada baris terakhir, yaitu \(R(j,j)\). Dengan demikian, dapat disimpulkan hasil integrasi melalui Romberg sebagai
\begin{equation*}
	\begin{split}
		\int_{a}^{b} f(x) \,dx & = R(j,j)
	\end{split}
\end{equation*}

\subsection{Implementasi Algoritma Romberg}

\subsubsection{Implementasi Menggunakan Octave}

\par Untuk tugas kelompok kedua ini, diberikan fungsi distribusi normal tabel Z sebagai berikut
\begin{equation*}
	\begin{split}
		P(Z \le z ) & = \phi(z) = \int_{-\infty}^{z} \frac{1}{\sqrt{2\pi}}e ^{\frac{-z^2}{2}} \,dz
	\end{split}
\end{equation*}

Pada TK ini, kami diminta untuk mengimplementasikan semua algoritma pada MATLAB/Octave. Maka dari itu, dibentuk implementasi dalam Octave untuk fungsi distribusi normal tersebut

\begin{center}
	\begin{lstlisting}[language=Octave]
	function ret = zNormalDist(z)
		ret = (1/sqrt(2.*pi)).*exp((-z.^2)/2);
	endfunction
	\end{lstlisting}
\end{center}

Berdasarkan penjelasan algoritma Romberg, kita bisa mengetahui bahwa dalam implementasinya, kita hanya perlu memanggil fungsi yang ingin diintegralkan. Dalam kasus ini, fungsi tersebut adalah fungsi distribusi normal yang sudah disebutkan di atas. Karena fungsi tersebut sudah dibuat implementasi Octavenya, maka kita hanya perlu membuat fungsi Romberg yang menerima fungsi distribusi normal tersebut. Implementasi algoritma Romberg dalam Octave merupakan translasi langsung dari rumus yang sudah disebutkan pada bagian sebelumnya, sehingga bisa diimplementasikan sebagai berikut
\begin{center}
	\begin{lstlisting}[language=Octave]
		function [res, R, j] = rombergIntegration(a, b, tol, f)

		if tol < 1e-14
		  printf("Tolerance is too small and will produce errors, please use larger values\n")
		  res = 0;
		  return;
		endif
	  
		n = 100;
		R = zeros(n, n);
		R(1,1) = (b-a)*(f(a)+f(b))/2;
	  
		for j = 2:n
		  h = (b-a)/2^(j-1);
		  Rval = 0;
	  
		  for i = 1:2^(j-2)
			Rval = Rval + f(a+(2*i - 1)*h);
		  endfor
	  
		  R(j,1) = (1/2)*R(j-1,1) + h*Rval;
	  
		  for k = 2:j
			topval = 4^(k-1)*R(j,k-1) - R(j-1,k-1);
			botval = 4^(k-1) - 1;
			R(j,k) = topval/botval;
		  endfor
	  
		  if abs(R(j,j)-R(j-1,j-1)) < tol
			break;
		  endif
	  
		endfor
	  
		R(1:j,1:j);
		res = R(j,j);
	  
	  endfunction
	\end{lstlisting}
\end{center}

Jika diperhatikan, fungsi ini memang hanya merupakan translasi dari rumus yang sudah diberikan. Perbedaannya, pada implementasi ini, tabel Romberg sudah didefinisikan dengan ukuran \(R(100,100)\). Hal ini merupakan asumsi di mana hasil komputasi tidak akan mencapai baris dan kolom ke-100 karena sifat Romberg yang menggunakan ekstrapolasi untuk mencari nilai paling akurat, sehingga seharusnya, berdasarkan asumsi, tidak akan memakan komputasi sebanyak itu.

Selain itu, diberikan juga \emph{guard} berupa batas toleransi maksimum dari perhitungan. Di awal, diberikan batas toleransi berupa \(tol < 1e-14\) yang berarti toleransi maksimum diperbolehkan hanya mencapai \(1e-13\). Hal ini dikarenakan fungsi referensi untuk perhitungan integral dari Octave yang akan digunakan pada laporan ini, yaitu \emph{quadgk}, memiliki batas toleransi mencapai \(1e-14\) sebagai nilai terendah dari hasil percobaan kami.

Ditambah pula, apabila nilai toleransi terlalu rendah, maka adanya kemungkinan terjadi error yang diakibatkan oleh limitasi komputasi oleh Octave yang dapat mengakibatkan hasil komputasi yang tidak akurat. Agar hal itu tidak terjadi, maka dibuatlah kondisi ini.

Toleransi maksimum juga ada di bagian bawah setelah iterasi kolom, yaitu ketika iterasi mencapai sel diagonal pada matriks. Apabila mencapai diagonal, sesuai pembahasan di atas, maka telah tercapai nilai paling akurat untuk iterasi tersebut. Di sini, akan diperiksa perbedaan antar diagonalnya. Seperti yang di bahas di atas, terjadi fenomena konvergensi pada diagonal di mana perbedaan antar diagonal menjadi semakin kecil dan semakin mendekati hasil akhir yang dituju. Ketika perbedaan ini sudah sangat kecil di bawah batas toleransi yang diinginkan, maka tidak ada tujuan lain untuk melanjutkan iterasi sehingga iterasi dihentikan.

Dengan demikian, fungsi tersebut akan menerima beberapa input berupa batas bawah integrasi, batas atas integrasi, batas toleransi yang diinginkan, dan fungsi yang akan di-\emph{pass}, dalam kasus ini adalah fungsi distribusi normal.

\subsubsection{Hasil Komputasi pada Octave}

Untuk melihat hasil implementasi, akan digunakan input dengan spesifikasi berikut

\begin{center}
	\begin{lstlisting}[language=Octave]
		minInf = -1e3;
		low = -1;
		high = 3;
		tol = 1e-7;
		
		printf("\nKalkulasi z-Score Integration dengan Romberg")
		printf("\nDengan spesifikasi sebagai berikut:")
		printf("\nLower Limit: %d", low)
		printf("\nUpper Limit: %d", high)
		printf("\nTolerance Limit: %d\n\n", tol)
	\end{lstlisting}
\end{center}

Jika dilihat, nilai minInf akan menggunakan \(1e-3\). Hal ini dikarenakan penggunaan nilai yang lebih kecil akan memakan komputasi lebih lama karena implementasi yang dilakukan akan menghitung dari nilai bawah yang sangat kecil tersebut. Selain itu, hasil komputasi fungsi distribusi normal di atas akan memiliki nilai yang sangat kecil untuk \(x \le 100\) sehingga akan menjadi redundan dan perbedaan akan tidak terlalu signifikan. Hal ini akan ditunjukkan pada contoh eksekusi implementasi kode di bawah.

Lalu, fungsi integrasi Romberg akan dipanggil dua kali untuk melihat 2 cara dari 2 pemanggilan/komputasi berbeda untuk distribusi normal. Sebelumnya, perlu diketahui bahwa fungsi distribusi normal bisa dihitung dengan dua cara. Misalkan kita ingin memanggil untuk suatu interval \(P(a \le Z \le b)\). Maka, bisa didefinisikan sebagai

\begin{equation*}
	\begin{split}
		P(a \le Z \le b )  = \phi(a,b) & = \int_{a}^{b} \frac{1}{\sqrt{2\pi}}e ^{\frac{-z^2}{2}} \,dz \\
		=  P(Z \le b ) - P(Z \le a )  = \phi(b)-\phi(a) & =  \int_{-\infty}^{b} \frac{1}{\sqrt{2\pi}}e ^{\frac{-z^2}{2}} - \int_{-\infty}^{a} \frac{1}{\sqrt{2\pi}}e ^{\frac{-z^2}{2}} \,dz
	\end{split}
\end{equation*}

Dengan demikian, dapat diimplementasikan pada Octave kedua pemanggilan tersebut

\begin{center}
	\begin{lstlisting}[language=Octave]
		printf("\nHasil Integrasi dengan P(a <= Z <= b)\n")

		[res, R, j] = rombergIntegration(low, high, tol, @zNormalDist);
		R(1:j,1:j)
		res
		
		printf("\nHasil Integrasi dengan P(Z <= b) - P(Z <= a)\n")
		
		[res1, R1, j1] = rombergIntegration(minInf, low, tol, @zNormalDist);
		res1
		
		[res2, R2, j2] = rombergIntegration(minInf, high, tol, @zNormalDist);
		res2
		
		printf("\n")
		ansMinInf = abs(res2-res1)
	\end{lstlisting}
\end{center}

Dengan \(R(1:j,1:j)\) adalah tabel Romberg dan \(res\) adalah hasil komputasi untuk pemanggilan \(rombergIntegration\). Untuk memperoleh hasil melalui cara \(P(Z \le b ) - P(Z \le a )\), maka akan dikeluarkan melalui pengurangan dan variabel \(ansMinInf\). Untuk kasus dengan spesifikasi di atas, akan menghasilkan \emph{output}

\begin{center}
	\begin{lstlisting}[language=Octave]
		Hasil Integrasi dengan P(a <= Z <= b)
		ans =
		
		Columns 1 through 3:
		
		0.492805145862163   0                   
		0.730344021969368   0.809523647338437   0
		0.818105257899305   0.847359003209284   0.849881360267340
		0.834640903793682   0.840152785758475   0.839672371261754
		0.838663131013866   0.840003873420594   0.839993945931402
		0.839662332840927   0.839995400116614   0.839994835229682
		0.839911744979600   0.839994882359158   0.839994847841994
		
		Columns 4 through 6:
		
		0
		0
		0 
		0.839510323817221	0
		0.839999050291238	0.840000966865646	0
		0.839994849345527	0.839994832871231	0.839994826875146
		0.839994848042189	0.839994848037078	0.839994848051903
	
		Column 7:
		
		0
		0
		0
		0
		0
		0
		0.839994848057074
		
		res = 0.839994848057074
		
		Hasil Integrasi dengan P(Z <= b) - P(Z <= a)
		res1 = 0.158655253936076
		res2 = 0.998650101990628
		
		ansMinInf = 0.839994848054551
	\end{lstlisting}
\end{center}

Dapat dilihat bahwa keduanya menghasilkan nilai yang cukup dekat antara satu dengan yang lainnya, dengan \(P(a \le Z \le b)= 0.839994848057074\)  dan \(P(Z \le b ) - P(Z \le a ) = 0.839994848054551\). Jika kita ingin melihat lebih detail, keduanya memiliki perbedaan sebagai berikut, dengan implementasi Octave dan hasilnya

\begin{center}
	\begin{lstlisting}[language=Octave]
		printf("\nPerbedaan Antara P(a <= Z <= b) dan P(Z <= b) - P(Z <= a)\n")
		diff = res - ansMinInf

		Perbedaan Antara P(a <= Z <= b) dan P(Z <= b) - P(Z <= a)
		diff = 2.522870801158206e-12
	\end{lstlisting}
\end{center}

Dapat dilihat bahwa perbedaannya sangat kecil, dengan tingkat perbedaan pada angka \(1e-12\) sehingga bisa dibilang keduanya memiliki perbedaan yang insiginifikan dan salah satu dari kedua implementasi bisa digunakan. Tetapi, perlu diketahui bahwa metode \(P(Z \le b ) - P(Z \le a )\) akan memakan waktu komputasi lebih lama karena harus menghitung dari batas bawah \(-inf\), yang pada implementasi ini berupa \(-1e3\) sehingga memakan \emph{resource} yang lebih besar. Maka, jika kita ingin menghitung pada interval \([a,b]\), lebih baik menggunakan implementasi \(P(a \le Z \le b)\).

\subsection{Toleransi Error}

\section{Kesimpulan}
Kesimpulan disini.

% % Example of a table from http://www.latextemplates.com/template/professional-table

\begin{thebibliography}{1}
	% Here are a few examples of different citations 
	% Book
	\bibitem{kopka_1999} % Note the label in the curly brackets. Use the cite the source; e.g., \cite{kopka_latex}
	H.~Kopka and P.~W. Daly, \emph{A Guide to \LaTeX}, 3rd~ed.\hskip 1em plus
	0.5em minus 0.4em\relax Harlow, England: Addison-Wesley, 1999.
	\bibitem{horowitz_2005}D.~Horowitz, \emph{End of Time}. New York, NY, USA: Encounter Books, 2005. [E-book] Available: ebrary, \url{http://site.ebrary.com/lib/sait/Doc?id=10080005}. Accessed on: Oct. 8, 2008.
	% Article from database
	\bibitem{castlevecchi_2008}D.~Castelvecchi, ``Nanoparticles Conspire with Free Radicals'' \emph{Science News}, vol.174, no. 6, p. 9, September 13, 2008. [Full Text]. Available: Proquest, \url{http://proquest.umi.com/pqdweb?index=52&did=1557231641&SrchMode=1&sid=3&Fmt=3&VInst=PROD&VType=PQD&RQT=309&VName=PQD&TS=1229451226&clientId=533}. Accessed on: Aug.~3, 2014.
	% Conference Paper from the Internet
	\bibitem{lach_2010}J.~Lach, ``SBFS: Steganography based file system,'' in \emph{Proceedings of the 2008 1st International Conference on Information Technology, IT 2008, 19-21 May 2008, Gdansk, Poland.} Available: IEEE Xplore, \url{http://www.ieee.org}. [Accessed: 10 Sept. 2010].
	% Web page, no author
	\bibitem{a_laymans_explanation}``A `layman's' explanation of Ultra Narrow Band technology,'' Oct.~3, 2003. [Online]. Available: \url{http://www.vmsk.org/Layman.pdf}. [Accessed: Dec.~3, 2003].
\end{thebibliography}

% This is a hand-made bibliography. If you want to use a BibTeX file, you're on your own ;-)














\end{document}